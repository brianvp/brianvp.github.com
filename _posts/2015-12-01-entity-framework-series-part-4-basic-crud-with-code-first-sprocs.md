---
id: 423
title: 'Entity Framework Series Part 4 &#8211; Basic CRUD with Code First + Sprocs'
date: 2015-12-01T20:43:33+00:00
author: brianvp
layout: post
guid: http://brianvanderplaats.com/?p=423
permalink: /2015/12/01/entity-framework-series-part-4-basic-crud-with-code-first-sprocs/
categories:
  - Development
  - Projects
tags:
  - Entity Framework
  - SQL Server
  - Visual Studio
---
<span style="font-weight: 400;">In </span>[<span style="font-weight: 400;">part 3</span>](http://brianvanderplaats.com/2015/11/11/entity-framework-series-part-3-basic-crud-with-edmx-sprocs/) <span style="font-weight: 400;">of this series I demonstrated using EDMX with stored procedures only.  In this article I do the same with Code First.  As discussed previously, while sprocs may be as far from the Code First ethos as you can get, you may find yourself in a situation where conventions and existing infrastructure require heavy use of sprocs.  The example code is up at <a href="https://github.com/brianvp/entityframework-examples/tree/master/EDMXBasicCRUDSprocs">github</a>.  </span>

## <span style="font-weight: 400;">Setting up Context and Classes</span>

<span style="font-weight: 400;">The first step is to set up a new DbContext Class, and entities for your tables.   Why do we want entities if we won’t be accessing tables directly?  Because we will be using Stored Procedure mapping for the CUD operations.  Additionally, you can re-map your sproc output class to match one of the default entities e.g. Model vs ModelSelectByKey_Result.  This will be useful for the update operation later on.  </span>

<span style="font-weight: 400;">You can see an example of this in </span>[<span style="font-weight: 400;">part 2</span>](http://brianvanderplaats.com/2015/10/27/entity-framework-series-part-2-basic-crud-with-code-first/)

## <span style="font-weight: 400;">Updating the Classes when the Database Changes</span>

<span style="font-weight: 400;">Before moving on to the examples, one important caveat &#8211; currently there is no way to add new classes to an existing context using the Code First from database wizard.  This is a serious drawback as EDMX has a very convenient “Update Model From Database” option.   </span>

<span style="font-weight: 400;">The workaround I found, which I posted on </span>[<span style="font-weight: 400;">stackoverflow</span>](http://stackoverflow.com/questions/22637350/how-to-synch-model-after-using-code-first-from-database-using-entity-framework-6)<span style="font-weight: 400;">, is as follows:</span>

<li style="font-weight: 400;">
  <span style="font-weight: 400;">Create a new Entity Data Model, called DBContextTemp or whatever, you will be deleting this at the end</span>
</li>
<li style="font-weight: 400;">
  <span style="font-weight: 400;">Choose the Code First from Database wizard option</span>
</li>
<li style="font-weight: 400;">
  <span style="font-weight: 400;">Select your new table(s) as objects to add, then complete the wizard</span>
</li>
<li style="font-weight: 400;">
  <span style="font-weight: 400;">Open your orignal DBContext file and add the following line for each of the new entity classes generated by the wizard:</span><span style="font-weight: 400;"><br /> ```csharp  public virtual DbSet<TableName> TableNamePlural { get; set ; }```
</li>
<li style="font-weight: 400;">
  <span style="font-weight: 400;">Remove DBContextTemp</span>
</li>

<span style="font-weight: 400;">This doesn't solve the problem of updating fields, but adjusting a few properties shouldn't be too difficult&#8230;</span>

## <span style="font-weight: 400;">Calling Sprocs via SQLQuery()</span>

<span style="font-weight: 400;">Ok so first the bad news &#8211; calling parameterized sprocs to return data with Code First is a real pain.  Here’s the code for executing the ModelSelectFilter  sproc:</span>

```csharp
var name = new SqlParameter("@name", DBNull.Value);
 var manufacturerCode = new SqlParameter("@manufacturercode", DBNull.Value);
 var categoryName = new SqlParameter("@categoryname", DBNull.Value);
 var description = new SqlParameter("@description", DBNull.Value);
 var features = new SqlParameter("@features", DBNull.Value);
 var minListPrice = new SqlParameter("@minListPrice", DBNull.Value);
 var maxListPrice = new SqlParameter("@maxListPrice", DBNull.Value);
 var statusName = new SqlParameter("@statusName", DBNull.Value);
 var manufacturerName = new SqlParameter("@manufacturerName", DBNull.Value);

 var models = db.Database.SqlQuery<ModelSelectFilter_Result>("product.ModelSelectFilter @name, @manufacturercode, @categoryname,@description,@features,@minListPrice,@maxListPrice,@statusName, @manufacturerName", 
 name,manufacturerCode, categoryName, description, features, minListPrice,maxListPrice,statusName,manufacturerName).ToList();
```

<span style="font-weight: 400;">compared to the same sproc using function mapping in EDMX:</span>

```csharp
var models = db.ModelSelectFilter(null,null,null,null,null,null,null,null,null);
```

<span style="font-weight: 400;">Yikes.   At this point there doesn’t seem to be much difference in using raw ado.net calls or some micro ORM such as </span>[<span style="font-weight: 400;">Dapper</span>](https://github.com/StackExchange/dapper-dot-net)<span style="font-weight: 400;">, which would look something like this:</span>

```csharp
var models = cnn.Query<Model>("product.ModelSelectFilter", new {name = null, manufacturerCode = null, categoryName = null, description = null, features = null, minListPrice = null, maxListPrice = null, statusName=null,manufacturerName=null }, commandType:CommandType.StoredProcedure ).ToList();
```

<span style="font-weight: 400;">Thankfully stored procedure mapping takes some of the pain out of this.</span>

## <span style="font-weight: 400;">StoredProcedure Mapping</span>

Stored procedure mapping allows us perform data operations on entities as if entity framework were generating the SQL itself.  <span style="font-weight: 400;">Mapping the CUD operations takes place in the OnModelCreating() method of the dbContext class.  For each entity you wish to map to, call the MapToStoredProcedures() method:</span>

```csharp
modelBuilder.Entity<Model>()
 .MapToStoredProcedures(s =>
 s.Update(u => u.HasName("product.ModelUpdate"))
 .Delete( d => d.HasName("product.ModelDelete"))
 .Insert( i => i.HasName("product.ModelInsert"))
 );
```

<span style="font-weight: 400;">Note if your sprocs use output parameters they will need to have a default value of null, and won&#8217;t be accessible through procedure mapping.  </span>

## <span style="font-weight: 400;">Create</span>

<span style="font-weight: 400;">Adding a model is very simple, and no different from direct table access, which is what we want:</span>

```csharp
var model = new Model { Name = "Domane 5.2", ListPrice = 3499.99m };

 db.Models.Add(model);
 db.SaveChanges();

 modelId = model.ModelId;
```

## <span style="font-weight: 400;">Update</span>

<span style="font-weight: 400;">Updating has some caveats, but not too bad.  First, you will need to load an instance of the entity, which you can do by changing the type of SqlQuery to <Model>:</span>

```csharp
var modelIdParam = new SqlParameter("@modelid", modelId);

var model = db.Database.SqlQuery<Model>("product.ModelSelectByKey @modelid", modelIdParam).SingleOrDefault();

if (model != null)
{
 db.Models.Attach(model);
 model.Features = "500 Series OCLV Frame";

 db.SaveChanges();
}
```

<span style="font-weight: 400;">Second, note that the new model will *not* be part of the db.Models collection.  If you update one or more fields and call db.SaveChanges(), nothing will happen.  You first need to attach the model to the Models collection.  This is a slight difference from EDMX where you  can set the function import to map a collection of Models, which the context will automatically detect changes to. </span>

## <span style="font-weight: 400;">Delete</span>

<span style="font-weight: 400;">Nothing complicated here again:</span>

```csharp
var model = new Model { ModelId = modelId };

 db.Models.Attach(model);
 db.Models.Remove(model);
 db.SaveChanges();
```

<span style="font-weight: 400;">Below is the full SQL Profiler trace of the test program:</span>

[<img class="alignnone size-full wp-image-428" src="http://brianvanderplaats.com/wp-content/uploads/2015/12/CodeFirstSprocProfileTrace.png" alt="CodeFirstSprocProfileTrace" width="889" height="312" />](http://brianvanderplaats.com/wp-content/uploads/2015/12/CodeFirstSprocProfileTrace.png)

## <span style="font-weight: 400;">Conclusion</span>

<span style="font-weight: 400;">So there you have it, a full set of CRUD operations in Code First using only sprocs.   After looking at both, my conclusion that if you use sprocs extensively or exclusively, Code First is not the right tool.  But if you were using a Code First in the majority of your application, I would not create an edmx file simply to interface with a handful of sprocs, Code First certainly can work with sprocs that interact with entities. </span>